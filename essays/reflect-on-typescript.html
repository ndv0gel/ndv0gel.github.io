<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflection on Typescript - Nathan Vogel</title>
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="../index.html">Home</a></li>
                <li><a href="../index.html#projects">Projects</a></li>
                <li><a href="../index.html#essays">Essays</a></li>
                <li><a href="../index.html#resume">Resume</a></li>
            </ul>
        </nav>
    </header>

    <main class="essay-detail">
        <article>
            <h1>Reflection on Typescript</h1>
            <div class="essay-content">
                <p>
                    Migration to TypeScript has been quite an enlightenment after my 
                    experiences with JavaScript and C. First, I had a lot of 
                    skepticism about adding this extra layer to JavaScript. With 
                    TypeScript, you have to appreciate its strong type system 
                    and how that alone will change development. Static typing would 
                    not just find the bugs possibly at creation time but is a form of 
                    built-in documentation and makes code much more understandable and
                    maintainable. Yet again, what really stands out is how much 
                    TypeScript's type interference system, though it requires a bit 
                    more upfront work in declaring types and interfaces, pays off great
                    in code reliability and developer confidence.
                </p>
        
                <p>
                    Software engineering-wise, TypeScript removes many of the historical
                    problems of JavaScript. The interface system allows for much better 
                    object-oriented programming patterns, while generics provide powerful
                    ways to write reusable, type-safe code. Instead of finding out at runtime 
                    that an object does not have a certain property, TypeScript catches these 
                    issues during development. The ability to set strict types on function 
                    parameters and return types has greatly reduced the number of runtime 
                    errors in my code, although some of the advanced features, required 
                    dedicated study time.
                </p>
        
                <p>
                    The software engineering approach, especially its practice WODs, 
                    was an unexpectedly effective learning method to learn TypeScript. While 
                    stressful at first, the time-pressured coding exercises forced me to act 
                    quickly and slowly get comfortable with the syntax and features of 
                    TypeScript. Repetitive practice WODs solidified concepts into autopilot 
                    habits rather than theoretical concepts. Although the timed nature of these 
                    exercises can be anxiety-inducing, I find this approach mirrors real-world 
                    scenarios where developers need to solve problems efficiently under time 
                    constraints. The immediate feedback loop of success or failure in these 
                    exercises provides clear metrics for improvement and helps identify areas 
                    needing additional focus.
                </p>
            </div>
            <p class="essay-date">January 26, 2024</p>
        </article>
    </main>

    <footer>
        <p>&copy; 2024 Nathan Vogel. All rights reserved.</p>
    </footer>
</body>
</html>
